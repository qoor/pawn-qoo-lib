//=================================================================================================
//											  QModule
//
//											version: v7.3
//											 author: Qoo
//								Copyright (c) 2019 Qoo. All rights reserved.
//
//=================================================================================================

/*개선 사항:
v1.0: 최초 릴리즈 (LA:RP 모듈 알고리즘을 참고했음.) Thank you for Acu.
v2.0:
	1. 'public:함수명' 문법 제거
	2. 문자열 관련 핸들러 처리 최적화
		ㄴ 기존에는 서버 크래시 방지를 위해 공백 문자를 방지하고자 문자열 변수를 만들고 콜백 파라미터의 문자열을 복사해서 전송했으나,
			문자열 내용이 비어있는 경우 \1 문자를, 그렇지 않은 경우 문자열을 그대로 전송하여 속도를 개선함.
		ㄴ 자세한 사항은 strfix 매크로 함수를 참고.
	3. 핸들러 호출을 도중에 끝낼 수 있는 EventInfoWithSuspend(이벤트ID, 이벤트 끝낼 반환값, 파라미터 포멧, 파마리터) 함수가 추가되었습니다.
	4. strfix 매크로 함수가 추가되었습니다.
		ㄴ 모든 이벤트들은 문자열 값을 핸들러에게 전달할 때 반드시 strfix 매크로 함수를 거쳐서 보내야 합니다. 그렇지 않으면 크래시가 일어납니다.
	5. OnPlayerCommandTextFail(playerid, const cmdtext[], const cmd[]) 콜백이 추가되었습니다.
		ㄴ OnPlayerCommandText의 핸들러에서 명령어를 찾지 못하면 해당 콜백이 호출됩니다.
v4.0:
	1. HandlerLoop (이벤트ID) 매크로가 추가되었습니다.
	2. HandlerAction (이벤트ID, 파라미터 포멧, 파라미터) 매크로 함수가 추가되었습니다.
v5.0:
	1. EventInfo, EventInfoWithSuspend 함수가 제거되고 TriggerEvent(이벤트ID, 이벤트 끝낼 반환값, 파라미터 포멧, 파마리터) 함수가 추가되었습니다.
	2. 단순히 함수를 호출하는 함수였던 TriggerEvent가 실제로 등록된 이벤트를 호출하는 함수로 개선되었습니다.
v5.1:
	1. AddEventHandler 함수에 우선순위 기능(priority 파라미터. default = MAX_HANDLER_FUNCTION / 2)이 추가되었습니다.
	2. TriggerEventWithBreak, TriggerEventNoSuspend 함수가 추가되었습니다.
v5.2:
	1. MainScript(), InitScript("모듈명") 함수가 각각 main(), InitModule("모듈명")으로 변경되었습니다.
	2. IsValidHandlerEvent(eventid)가 IsValidEvent(eventid)로 변경되었습니다.
v5.3:
	1. OnPlayerCommandTextFail 콜백을 제거하고 명령어를 찾지 못할 시 D_PlayerCommandTextFail 이벤트가 호출됩니다.
		ㄴ 기존의 OnPlayerCommandTextFail 콜백에 쓰던 파라미터 형식은 그대로 입니다.
	2. QMODULE_ENGINE_VERSION 매크로가 추가되었습니다.
v5.4:
	1. 문자열 파라미터가 포함되는 native 이벤트들의 성능을 최적화했습니다.
		ㄴ 앞으로 문자열 파라미터가 포함되는 사용자 정의 이벤트를 호출하기 전에 미리 문자열 파라미터들은 strfix 함수를 거쳐야 합니다.
	2. strfix(const source[]) 매크로 함수가 strfix(source[]) 함수로 변경되었습니다.
v5.5:
	1. 플레이어 명령어 처리에 대한 시스템을 대폭 변경하였습니다.
		ㄴ 기존에는 만약 '/1234 5678 90'이라고 입력 했을 때 playerid, cmdtext[] = "/1234 5678 90", cmd[] = "/1234" 형식으로 전달 되었고 명령어 뒤에 오는 파라미터들은 strtok로 나눴지만,
		변경 후 playerid, command[] = "/1234", params[] = "5678 90" 형식으로 전달 됩니다.
	2. GetParamPoint 함수가 추가 되었습니다.
		ㄴ const params[]: D_PlayerCommandText의 params 값이나 기타 공백으로 데이터를 나눠야 하는 문자열의 총 집합을 넣습니다.
		ㄴ index: 파라미터를 쪼개어 몇 번째 파라미터를 검색 할 것인지 알려줍니다. (파라미터 인덱스는 0부터 시작합니다.)
		ㄴ &start: index번째 파라미터의 문자열 시작 지점을 반환 합니다. 찾지 못한 경우 -1이 반환됩니다.
		ㄴ &end: index번째 파라미터의 문자열 끝 지점을 반환 합니다. 찾지 못한 경우 -1이 반환됩니다.
		ㄴ delimiter = ' ': 파라미터들을 구분하는 문자를 지정합니다. 명령어는 보통 공백으로 파라미터를 나누므로 기본값은 공백입니다.
		ㄴ 반환 값: index번째 파라미터를 찾은 경우 1을, 그렇지 않은 경우 0을 반환합니다.
	3. IsValidParamIndex 함수가 추가 되었습니다.
		ㄴ const params[]: D_PlayerCommandText의 params 값이나 기타 공백으로 데이터를 나눠야 하는 문자열의 총 집합을 넣습니다.
		ㄴ index: 파라미터를 쪼개어 몇 번째 파라미터를 검색 할 것인지 알려줍니다. (파라미터 인덱스는 0부터 시작합니다.)
		ㄴ delimiter = ' ': 파라미터들을 구분하는 문자를 지정합니다. 명령어는 보통 공백으로 파라미터를 나누므로 기본값은 공백입니다.
		ㄴ 반환 값: index번째 파라미터를 찾은 경우 1을, 그렇지 않은 경우 0을 반환 합니다.
	4. GetParamString 함수가 추가 되었습니다.
		ㄴ dest[]: index번째 파라미터의 문자열 값이 들어갈 변수를 넘겨줍니다. index번째 파라미터를 찾지 못한 경우 NULL값이 입력됩니다.
		ㄴ const params[]: D_PlayerCommandText의 params 값이나 기타 공백으로 데이터를 나눠야 하는 문자열의 총 집합을 넣습니다.
		ㄴ index: 파라미터를 쪼개어 몇 번째 파라미터를 검색 할 것인지 알려줍니다. (파라미터 인덱스는 0부터 시작합니다.)
		ㄴ size = sizeof(dest): dest 문자열의 배열 길이를 입력합니다.
		ㄴ delimiter = ' ': 파라미터들을 구분하는 문자를 지정합니다. 명령어는 보통 공백으로 파라미터를 나누므로 기본값은 공백입니다.
		ㄴ 반환 값: index번째 파라미터를 찾은 경우 1을, 그렇지 않은 경우 0을 반환합니다.
	5. GetParamInt, GetParamFloat 함수가 추가 되었습니다.
		ㄴ &var: index번째 파라미터에 들어있는 값이 들어갈 변수를 넘겨줍니다. index번째 파라미터를 찾지 못한 경우 값 변경이 이뤄지지 않습니다.
		ㄴ const params[]: D_PlayerCommandText의 params 값이나 기타 공백으로 데이터를 나눠야 하는 문자열의 총 집합을 넣습니다.
		ㄴ index: 파라미터를 쪼개어 몇 번째 파라미터를 검색 할 것인지 알려줍니다. (파라미터 인덱스는 0부터 시작합니다.)
		ㄴ delimiter = ' ': 파라미터들을 구분하는 문자를 지정합니다. 명령어는 보통 공백으로 파라미터를 나누므로 기본값은 공백입니다.
		ㄴ 반환 값: index번째 파라미터를 찾은 경우 1을, 그렇지 않은 경우 0을 반환 합니다.
	6. MergeParams 함수가 추가 되었습니다.
		ㄴ dest[]: index번째 파라미터 부터 마지막 파라미터까지 합친 문자열 값이 들어갈 변수를 넘겨줍니다. index번째 파라미터를 찾지 못한 경우 NULL값이 입력됩니다.
		ㄴ const params[]: D_PlayerCommandText의 params 값이나 기타 공백으로 데이터를 나눠야 하는 문자열의 총 집합을 넣습니다.
		ㄴ startIndex: 파라미터를 쪼개어 몇 번째 파라미터 부터 합칠 것인지 알려줍니다. (파라미터 인덱스는 0부터 시작합니다.)
		ㄴ size = sizeof(dest): dest 문자열의 배열 길이를 입력합니다.
		ㄴ delimiter = ' ': 파라미터들을 구분하는 문자를 지정합니다. 명령어는 보통 공백으로 파라미터를 나누므로 기본값은 공백입니다.
		ㄴ 반환 값: 파라미터 합치기를 성공했을 경우 1을, 그렇지 않은 경우 0을 반환 합니다.
v6.0:
	1. SA-MP 버전 0.3z와 0.3.7을 공식 지원합니다.
		ㄴ 3가지의 SA-MP 버전을 완벽히 지원합니다. (0.3d, 0.3z, 0.3.7)
		ㄴ QMODULE_SAMP_VERSION 부분을 필히 서버 버전과 일치하게 바꿔주셔야 합니다.
		ㄴ 추후 0.3.7 후속 버전이 생기더라도 0.3.7 모드로 사용 가능합니다. 단, 새로운 버전에서 추가되는 일부 콜백들은 이벤트가 존재하지 않기 때문에 직접 인클루드를 수정해 주시거나, AddEvent, TriggerEvent로 사용자 정의 이벤트를 생성해 해결 할 것을 추천합니다.
v7.0:
	1. QContainer와의 playerList 연동 옵션이 추가되었습니다.
		ㄴ QContainer를 이용하여 playerList를 사용하고 싶을 경우 QMODULE_QCONTAINER_PLAYERLIST 값을 1로 바꾸시면 됩니다.
		ㄴ QContainer를 사용하는 경우 되도록이면 옵션을 켜는 것을 추천합니다. 이 옵션을 꺼도 playerList를 모드에서 다른 방법을 써서 똑같이 사용 가능하지만, 코드가 복잡해지고 구조 이해가 힘들어집니다.
		ㄴ playerList란, 두 인클루드를 연동 시 기존의 단순 반복문을 통한 플레이어 반복문이 아니라, 접속한 유저만 빠르게 검사하고 플레이어 접속 정보를 담아둔 Container 변수입니다.
		ㄴ IsPlayerConnected 함수도 같이 후킹됩니다. playerList를 통해 빠르게 플레이어 접속 여부를 알려줍니다. 반드시 가장 마지막에 QModule을 포함해 주십시오. 그렇지 않으면 QModule보다 나중에 포함 된 인클루드들과 호환성 문제가 생길 수 있습니다.
		ㄴ 플레이어 루프문의 예시는 contloop (new i : playerList) { ... } or contloop (i : playerList) { ... } 등과 같은 형식으로 이용 가능합니다.
v7.1
	1. Params 기능들의 구조가 약간씩 변경되었고, 성능이 향상되었습니다.
		ㄴ 매 함수들마다 맨 앞 인자로 값이 들어갈 변수를 지정해야 합니다.
		ㄴ Ex) new intVar; GetParamInt(intVar, params, 0);
		ㄴ GetParamInt와 GetParamFloat는 더이상 반환값으로 결과값이 들어가는 것이 아닌, 값이 올바르게 추출되었는지에 대한 여부를 반환합니다.
		ㄴ new intVar; if (GetParamInt(intVar, params, 0) == 0) { ... } 이건 '만약 0번째 파라미터를 찾을 수 없을 경우'에 대한 조건문이고 파라미터를 찾았다면 이 조건문은 충족되지 않으며, intVar에 결과값이 들어갑니다.
		ㄴ 또한, GetParamPoint에서만 delimiter 지정이 가능했지만 이제는 모든 Params 함수들에서 delimiter을 지정할 수 있습니다.
		ㄴ v5.5의 Changelog에 있는 Params 함수들의 설명이 변경됩니다.
		ㄴ 이 업데이트 이후부터 IsValidParamIndex는 값을 활용하는 것이 아니라 오로지 검색만 할 경우와 같은 제한적인 상황에서만 사용하시는 것을 권장합니다.
v7.2
	1. Params 기능들을 QString으로 이전하였습니다.
	2. strfix 함수를 QString으로 이전하였습니다.
	3. 일부 문자열 함수 인자들에 const를 추가하였습니다.

v7.3
	1. SA-MP 0.3.7 미만 버전들의 지원이 종료 되었습니다.
*/

#if defined _QModule_included
	#endinput
#endif
#define _QModule_included
#pragma library QModule

#define QMODULE_QCONTAINER_PLAYERLIST 1

#include <a_samp>
#include <QString>

#if QMODULE_QCONTAINER_PLAYERLIST != 0
	#include <QContainer>
#endif

#define QMODULE_ENGINE_VERSION "v7.3"

main() { return 1; }

#define main() forward __InitMain(); public __InitMain()
#define InitModule("%0") forward LoadModule_%0(); public LoadModule_%0()

#define HandlerLoop(%0) for(new %0_i = 0, %0_j = handlerIDX[%0]; %0_i < %0_j; %0_i ++)
#define HandlerAction(%0,"%1"%2) CallLocalFunction(handlerName[%0][%0_i], #%1%2)
/*#define TriggerEvent(%0,"%1"%2) HandlerLoop(%0) CallLocalFunction(handlerName[%0][%0_i], #%1%2)
#define TriggerEvent(%0,%1,"%2"%3); HandlerLoop(%0) { if((CallLocalFunction(handlerName[%0][%0_i], #%2%3)) == %1) return %1; }*/
#define TriggerEvent(%0,%1,%2); HandlerLoop(%0) { if((HandlerAction(%0, %2)) == %1) return %1; }
#define TriggerEventWithBreak(%0,%1,%2); HandlerLoop(%0) { if((HandlerAction(%0, %2)) == %1) break; }
#define TriggerEventNoSuspend(%0,%1); HandlerLoop(%0) { HandlerAction(%0, %1); }

//#define strfix(%0) if (%0[0] == 0) %0[0] = '\1'

#define MAX_EVENTS 128
#define MAX_HANDLER_FUNCTION 128

#define D_FilterScriptInit 0
#define D_GameModeInit 1
#define D_FilterScriptExit 2
#define D_GameModeExit 3
#define D_PlayerRequestClass 4
#define D_PlayerConnect 5
#define D_PlayerDisconnect 6
#define D_PlayerSpawn 7
#define D_PlayerDeath 8
#define D_VehicleSpawn 9
#define D_VehicleDeath 10
#define D_PlayerText 11
#define D_PlayerCommandText 12
#define D_PlayerEnterVehicle 13
#define D_PlayerExitVehicle 14
#define D_PlayerStateChange 15
#define D_PlayerEnterCheckpoint 16
#define D_PlayerLeaveCheckpoint 17
#define D_PlayerEnterRaceCheckpoint 18
#define D_PlayerLeaveRaceCheckpoint 19
#define D_RconCommand 20
#define D_PlayerRequestSpawn 21
#define D_ObjectMoved 22
#define D_PlayerObjectMoved 23
#define D_PlayerPickUpPickup 24
#define D_VehicleMod 25
#define D_VehiclePaintjob 26
#define D_VehicleRespray 27
#define D_PlayerSelectedMenuRow 28
#define D_PlayerExitedMenu 29
#define D_PlayerInteriorChange 30
#define D_PlayerKeyStateChange 31
#define D_RconLoginAttempt 32
#define D_PlayerUpdate 33
#define D_PlayerStreamIn 34
#define D_PlayerStreamOut 35
#define D_VehicleStreamIn 36
#define D_VehicleStreamOut 37
#define D_DialogResponse 38
#define D_PlayerClickPlayer 39
#define D_PlayerExitMenu 40
#define D_PlayerGiveDamage 41
#define D_PlayerTakeDamage 42
#define D_PlayerClickMap 43
#define D_VehicleDamageStatusUpdate 44
#define D_UnoccupiedVehicleUpdate 45
#define D_EnterExitModShop 46
#define D_PlayerEditObject 48
#define D_PlayerEditAttachedObject 49
#define D_PlayerSelectObject 50
#define D_PlayerClickTextDraw 51
#define D_PlayerClickPlayerTextDraw 52
#define D_IncomingConnection 53
#define D_PlayerWeaponShot 54
#define D_TrailerUpdate 55
#define D_ActorStreamIn 56
#define D_ActorStreamOut 57
#define D_PlayerGiveDamageActor 58
#define D_VehicleSirenStateChange 59
#define D_PlayerCommandTextFail 60

new _scriptLoaded;

new moduleName[MAX_HANDLER_FUNCTION][21];
new moduleIDX;

new handlerName[MAX_EVENTS][MAX_HANDLER_FUNCTION][32];
new handlerPriority[MAX_EVENTS][MAX_HANDLER_FUNCTION];
new handlerIDX[MAX_EVENTS];

new eventIDX;

#if QMODULE_QCONTAINER_PLAYERLIST != 0
	CreateContainer(playerList, MAX_PLAYERS);

	stock Qoo_IsPlayerConnected(playerid)
	{
		return (IsValidContainerData(playerList, playerid));
	}
	#if defined _ALS_IsPlayerConnected
		#undef IsPlayerConnected
	#else
		#define _ALS_IsPlayerConnected
	#endif
	#define IsPlayerConnected Qoo_IsPlayerConnected
#endif

stock QModule_strlen(const string[])
{
	if (IsNull(string)) return 0;

	return strlen(string);
}
#if defined _ALS_strlen
	#undef strlen
#else
	#define _ALS_strlen
#endif
#define strlen QModule_strlen

public OnFilterScriptInit()
{
	#if defined FILTERSCRIPT
		if(_scriptLoaded == 0) InitializeQModule(0);
	#endif

	TriggerEvent(D_FilterScriptInit, 1, "");

	return 1;
}

public OnGameModeInit()
{
	#if !defined FILTERSCRIPT
		if(_scriptLoaded == 0) InitializeQModule(1);
	#endif

	TriggerEvent(D_GameModeInit, 1, "");

	return 1;
}

public OnFilterScriptExit()
{
	TriggerEvent(D_FilterScriptExit, 1, "");

	return 1;
}

public OnGameModeExit()
{
	TriggerEvent(D_GameModeExit, 1, "");

	return 1;
}

public OnPlayerRequestClass(playerid, classid)
{
	TriggerEvent(D_PlayerRequestClass, 0, "ii", playerid, classid);

	return 1;
}

public OnPlayerConnect(playerid)
{
	new name[MAX_PLAYER_NAME];

	GetPlayerName(playerid, name, MAX_PLAYER_NAME);

	if (strlen(name) >= 3)
	{
		#if QMODULE_QCONTAINER_PLAYERLIST != 0
			AddContainerData(playerList, playerid);
		#endif

		TriggerEvent(D_PlayerConnect, 1, "i", playerid);
	}
	
	return 1;
}

public OnPlayerDisconnect(playerid, reason)
{
	#if QMODULE_QCONTAINER_PLAYERLIST != 0
		if (IsPlayerConnected(playerid))
		{
			TriggerEvent(D_PlayerDisconnect, 1, "ii", playerid, reason);

			RemoveContainerData(playerList, playerid);
		}
	#else
		TriggerEvent(D_PlayerDisconnect, 1, "ii", playerid, reason);
	#endif

	return 1;
}

public OnPlayerSpawn(playerid)
{
	TriggerEvent(D_PlayerSpawn, 1, "i", playerid);

	return 1;
}

public OnPlayerDeath(playerid, killerid, reason)
{
	TriggerEvent(D_PlayerDeath, 1, "iii", playerid, killerid, reason);

	return 1;
}

public OnVehicleSpawn(vehicleid)
{
	TriggerEvent(D_VehicleSpawn, 1, "i", vehicleid);

	return 1;
}

public OnVehicleDeath(vehicleid, killerid)
{
	TriggerEvent(D_VehicleDeath, 1, "ii", vehicleid, killerid);

	return 1;
}

public OnPlayerText(playerid, text[])
{
	strfix(text);

	TriggerEvent(D_PlayerText, 0, "is", playerid, text);

	return 1;
}

public OnPlayerCommandText(playerid, cmdtext[])
{
	new command[145];
	new params[145];

	ParamInitialize(command, params, cmdtext);
	strfix(command);
	strfix(params);
	TriggerEvent(D_PlayerCommandText, 1, "iss", playerid, command, params);

#if defined FILTERSCRIPT
	return 0;
#else
	TriggerEvent(D_PlayerCommandTextFail, 1, "is", playerid, command);

	return 1;
#endif
}

public OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)
{
	TriggerEvent(D_PlayerEnterVehicle, 1, "iii", playerid, vehicleid, ispassenger);

	return 1;
}

public OnPlayerExitVehicle(playerid, vehicleid)
{
	TriggerEvent(D_PlayerExitVehicle, 1, "ii", playerid, vehicleid);

	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
	TriggerEvent(D_PlayerStateChange, 1, "iii", playerid, newstate, oldstate);

	return 1;
}

public OnPlayerEnterCheckpoint(playerid)
{
	TriggerEvent(D_PlayerEnterCheckpoint, 1, "i", playerid);

	return 1;
}

public OnPlayerLeaveCheckpoint(playerid)
{
	TriggerEvent(D_PlayerLeaveCheckpoint, 1, "i", playerid);

	return 1;
}

public OnPlayerEnterRaceCheckpoint(playerid)
{
	TriggerEvent(D_PlayerEnterRaceCheckpoint, 1, "i", playerid);

	return 1;
}

public OnPlayerLeaveRaceCheckpoint(playerid)
{
	TriggerEvent(D_PlayerLeaveRaceCheckpoint, 1, "i", playerid);

	return 1;
}

public OnRconCommand(cmd[])
{
	new val;

	strfix(cmd);

	HandlerLoop(D_RconCommand)
	{
		if((val = HandlerAction(D_RconCommand, "s", cmd)) == 1) break;
	}

	if(val == 0) printf(" Unknown command: %s", cmd);

	return 1;
}

public OnPlayerRequestSpawn(playerid)
{
	TriggerEvent(D_PlayerRequestClass, 0, "i", playerid);

	return 1;
}

public OnObjectMoved(objectid)
{
	TriggerEvent(D_ObjectMoved, 1, "i", objectid);

	return 1;
}

public OnPlayerObjectMoved(playerid, objectid)
{
	TriggerEvent(D_PlayerObjectMoved, 1, "ii", playerid, objectid);

	return 1;
}

public OnPlayerPickUpPickup(playerid, pickupid)
{
	TriggerEvent(D_PlayerPickUpPickup, 1, "ii", playerid, pickupid);

	return 1;
}

public OnVehicleMod(playerid, vehicleid, componentid)
{
	TriggerEvent(D_VehicleMod, 0, "iii", playerid, vehicleid, componentid);

	return 1;
}

public OnVehiclePaintjob(playerid, vehicleid, paintjobid)
{
	TriggerEvent(D_VehiclePaintjob, 0, "iii", playerid, vehicleid, paintjobid);

	return 1;
}

public OnVehicleRespray(playerid, vehicleid, color1, color2)
{
	TriggerEvent(D_VehicleRespray, 0, "iiii", playerid, vehicleid, color1, color2);

	return 1;
}

public OnPlayerSelectedMenuRow(playerid, row)
{
	TriggerEvent(D_PlayerSelectedMenuRow, 1, "ii", playerid, row);

	return 1;
}

public OnPlayerExitedMenu(playerid)
{
	TriggerEvent(D_PlayerExitMenu, 1, "i", playerid);

	return 1;
}

public OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)
{
	TriggerEvent(D_PlayerInteriorChange, 1, "iii", playerid, newinteriorid, oldinteriorid);

	return 1;
}

public OnPlayerKeyStateChange(playerid, newkeys, oldkeys)
{
	TriggerEvent(D_PlayerKeyStateChange, 1, "iii", playerid, newkeys, oldkeys);

	return 1;
}

public OnRconLoginAttempt(ip[], password[], success)
{
	strfix(ip);
	strfix(password);

	TriggerEvent(D_RconLoginAttempt, 1, "ssi", ip, password, success);

	return 1;
}

public OnPlayerUpdate(playerid)
{
	TriggerEvent(D_PlayerUpdate, 0, "i", playerid);

	return 1;
}

public OnPlayerStreamIn(playerid, forplayerid)
{
	TriggerEvent(D_PlayerStreamIn, 1, "ii", playerid, forplayerid);

	return 1;
}

public OnPlayerStreamOut(playerid, forplayerid)
{
	TriggerEvent(D_PlayerStreamOut, 1, "ii", playerid, forplayerid);

	return 1;
}

public OnVehicleStreamIn(vehicleid, forplayerid)
{
	TriggerEvent(D_VehicleStreamIn, 1, "ii", vehicleid, forplayerid);

	return 1;
}

public OnVehicleStreamOut(vehicleid, forplayerid)
{
	TriggerEvent(D_VehicleStreamOut, 1, "ii", vehicleid, forplayerid);

	return 1;
}

public OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])
{
	strfix(inputtext);

	TriggerEvent(D_DialogResponse, 1, "iiiis", playerid, dialogid, response, listitem, inputtext);

	return 0;
}

public OnPlayerClickPlayer(playerid, clickedplayerid, source)
{
	TriggerEvent(D_PlayerClickPlayer, 1, "iii", playerid, clickedplayerid, source);

	return 1;
}

public OnPlayerClickMap(playerid, Float: fX, Float: fY, Float: fZ)
{
	TriggerEvent(D_PlayerClickMap, 1, "ifff", playerid, fX, fY, fZ);

	return 1;
}

public OnVehicleDamageStatusUpdate(vehicleid, playerid)
{
	TriggerEvent(D_VehicleDamageStatusUpdate, 1, "ii", vehicleid, playerid);

	return 1;
}

public OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat)
{
	TriggerEvent(D_UnoccupiedVehicleUpdate, 0, "iii", vehicleid, playerid, passenger_seat);

	return 1;
}

public OnEnterExitModShop(playerid, enterexit, interiorid)
{
	TriggerEvent(D_EnterExitModShop, 1, "iii", playerid, enterexit, interiorid);

	return 1;
}

public OnPlayerGiveDamage(playerid, damagedid, Float: amount, weaponid, bodypart)
{
	TriggerEvent(D_PlayerGiveDamage, 1, "iifii", playerid, damagedid, amount, weaponid, bodypart);

	return 0;
}

public OnPlayerTakeDamage(playerid, issuerid, Float: amount, weaponid, bodypart)
{
	TriggerEvent(D_PlayerTakeDamage, 1, "iifii", playerid, issuerid, amount, weaponid, bodypart);

	return 0;
}

public OnPlayerEditObject(playerid, playerobject, objectid, response, Float: fX, Float: fY, Float: fZ, Float: fRotX, Float: fRotY, Float: fRotZ)
{
	TriggerEvent(D_PlayerEditObject, 1, "iiiiffffff", playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ);

	return 0;
}

public OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, Float: fOffsetX, Float: fOffsetY, Float: fOffsetZ, Float: fRotX, Float: fRotY, Float: fRotZ, Float: fScaleX, Float: fScaleY, Float: fScaleZ)
{
	TriggerEvent(D_PlayerEditAttachedObject, 1, "iiiiifffffffff", playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ);

	return 0;
}

public OnPlayerSelectObject(playerid, type, objectid, modelid, Float: fX, Float: fY, Float: fZ)
{
	TriggerEvent(D_PlayerSelectObject, 1, "iiiifff", playerid, type, objectid, modelid, fX, fY, fZ);

	return 0;
}

public OnPlayerClickTextDraw(playerid, Text: clickedid)
{
	TriggerEvent(D_PlayerClickTextDraw, 1, "ii", playerid, _: clickedid);

	return 0;
}

public OnPlayerClickPlayerTextDraw(playerid, PlayerText: playertextid)
{
	TriggerEvent(D_PlayerClickTextDraw, 1, "ii", playerid, _: playertextid);

	return 0;
}

public OnIncomingConnection(playerid, ip_address[], port)
{
	TriggerEvent(D_IncomingConnection, 1, "isi", playerid, ip_address, port);

	return 0;
}

public OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, Float: fX, Float: fY, Float: fZ)
{
	TriggerEvent(D_PlayerWeaponShot, 0, "iiiifff", playerid, weaponid, hittype, hitid, fX, fY, fZ);

	return 1;
}

public OnTrailerUpdate(playerid, vehicleid)
{
	TriggerEvent(D_TrailerUpdate, 0, "ii", playerid, vehicleid);

	return 1;
}

public OnActorStreamIn(actorid, forplayerid)
{
	TriggerEvent(D_ActorStreamIn, 1, "ii", actorid, forplayerid);

	return 1;
}

public OnActorStreamOut(actorid, forplayerid)
{
	TriggerEvent(D_ActorStreamIn, 1, "ii", actorid, forplayerid);

	return 1;
}

public OnPlayerGiveDamageActor(playerid, damaged_actorid, Float: amount, weaponid, bodypart)
{
	TriggerEvent(D_PlayerGiveDamageActor, 1, "iifii", playerid, damaged_actorid, amount, weaponid, bodypart);

	return 0;
}

public OnVehicleSirenStateChange(playerid, vehicleid, newstate)
{
	TriggerEvent(D_VehicleSirenStateChange, 1, "iii", playerid, vehicleid, newstate);

	return 0;
}

stock AddEvent(const eventName[])
{
	if(eventIDX >= MAX_EVENTS)
	{
		print("[QModule] Event is already full. Max event amount: "#MAX_EVENTS"");
		return -1;
	}
	if(IsNull(eventName)) {} // ignore warning
	
	#if defined QMODULE_DEBUG_MODE
		printf("[QModule] Event (ID: %d) was added.", eventIDX);
	#endif
	
	return eventIDX++;
}

stock AddEventHandler(eventid, const handlerFunction[], priority = MAX_HANDLER_FUNCTION / 2)
{
	if(IsValidEvent(eventid) == 0) return 0;
	if(IsNull(handlerFunction))
	{
		printf("[QModule] Invalid handler function (Event ID: %d)", eventid);
		return 0;
	}
	if(funcidx(handlerFunction) == -1)
	{
		printf("[QModule] Undefined symbol \"%s\"", handlerFunction);
		return 0;
	}

	new i;
	new idx = handlerIDX[eventid];

	for(i = 0; i < idx; i ++)
	{
		if(strcmp(handlerName[eventid][i], handlerFunction) == 0)
		{
			printf("[QModule] Event ID(id: %d) of handler \"%s\" is already defined.", eventid, handlerFunction);
			return 0;
		}
	}


	if(idx >= MAX_HANDLER_FUNCTION)
	{
		printf("[QModule] Event ID(id: %d) of handler is already full. Max handler amount: "#MAX_HANDLER_FUNCTION"", eventid);
		return 0;
	}

	if(priority == -1) idx = 0;
	else
	{
		for(i = 0; i < MAX_HANDLER_FUNCTION; ++i)
		{
			if(handlerPriority[eventid][i] > priority)
			{
				idx = i;

				break;
			}
		}
	}

	if(idx != handlerIDX[eventid])
	{
		new maxIdx = MAX_HANDLER_FUNCTION - 1;

		for(i = maxIdx; i > idx; --i)
		{
			handlerName[eventid][i] = handlerName[eventid][i - 1];
			handlerPriority[eventid][i] = handlerPriority[eventid][i - 1];
		}
	}
	
	strcpy(handlerName[eventid][idx], handlerFunction);
	if(charfind(handlerName[eventid][idx], 0) == -1) handlerName[eventid][idx][31] = 0;

	++handlerIDX[eventid];
	
	#if defined QMODULE_DEBUG_MODE
		printf("[QModule] \"%s\" Handler was added for Event (ID: %d)", handlerFunction, eventid);
	#endif
	
	return 1;
}

stock RemoveEventHandler(eventid, const handlerFunction[])
{
	if(IsValidEvent(eventid) == 0) return 0;
	if(IsNull(handlerFunction))
	{
		printf("[QModule] Invalid handler function name. (Event ID: %d)", eventid);
		return 0;
	}
	if(funcidx(handlerFunction) == -1)
	{
		printf("[QModule] Undefined symbol \"%s\"", handlerFunction);
		return 0;
	}
	
	new idx = handlerIDX[eventid];

	for(new i = 0; i < idx; i ++)
	{
		if(strcmp(handlerName[eventid][i], handlerFunction) == 0)
		{
			handlerIDX[eventid]--;
			idx -= 1;
			
			for(new j = i; j < idx; j ++)
			{
				handlerName[eventid][j] = handlerName[eventid][j + 1];
				handlerPriority[eventid][j] = handlerPriority[eventid][j + 1];
			}

			handlerName[eventid][idx] = "";
			
			#if defined QMODULE_DEBUG_MODE
				printf("[QModule] \"%s\" Handler was removed for Event (ID: %d)", handlerFunction, eventid);
			#endif
			
			return 1;
		}
	}

	return 0;
}

stock AddModule(const module[])
{
	if(moduleIDX >= MAX_HANDLER_FUNCTION)
	{
		print("[QModule] Module is already full. Max module amount: "#MAX_HANDLER_FUNCTION"");
		return 0;
	}
	if(IsNull(module))
	{
		print("[QModule] Invalid module name.");
		return 0;
	}
	
	for(new i = 0; i < moduleIDX; i++)
	{
		if(strcmp(moduleName[i], module) == 0)
		{
			printf("[QModule] Module \"%s\" is already defined.", module);
			return 0;
		}
	}
	
	strcpy(moduleName[moduleIDX], module);
	if(charfind(moduleName[moduleIDX], 0) == -1) moduleName[moduleIDX][20] = 0;
	moduleIDX++;
	
	#if defined QMODULE_DEBUG_MODE
		printf("[QModule] \"%s\" Module was added.", module);
	#endif
	
	new chString[32];
	format(chString, 32, "LoadModule_%s", module);
	CallLocalFunction(chString, "");
	return 1;
}

stock InitializeQModule(type)
{
	_scriptLoaded = 1;

	AddEvent("OnFilterScriptInit");
	AddEvent("OnGameModeInit");
	AddEvent("OnFilterScriptExit");
	AddEvent("OnGameModeExit");
	AddEvent("OnPlayerRequestClass");
	AddEvent("OnPlayerConnect");
	AddEvent("OnPlayerDisconnect");
	AddEvent("OnPlayerSpawn");
	AddEvent("OnPlayerDeath");
	AddEvent("OnVehicleSpawn");
	AddEvent("OnVehicleDeath");
	AddEvent("OnPlayerText");
	AddEvent("OnPlayerCommandText");
	AddEvent("OnPlayerEnterVehicle");
	AddEvent("OnPlayerExitVehicle");
	AddEvent("OnPlayerStateChange");
	AddEvent("OnPlayerEnterCheckpoint");
	AddEvent("OnPlayerLeaveCheckpoint");
	AddEvent("OnPlayerEnterRaceCheckpoint");
	AddEvent("OnPlayerLeaveRaceCheckpoint");
	AddEvent("OnRconCommand");
	AddEvent("OnPlayerRequestSpawn");
	AddEvent("OnObjectMoved");
	AddEvent("OnPlayerObjectMoved");
	AddEvent("OnPlayerPickUpPickup");
	AddEvent("OnVehicleMod");
	AddEvent("OnVehiclePaintjob");
	AddEvent("OnVehicleRespray");
	AddEvent("OnPlayerSelectedMenuRow");
	AddEvent("OnPlayerExitedMenu");
	AddEvent("OnPlayerInteriorChange");
	AddEvent("OnPlayerKeyStateChange");
	AddEvent("OnRconLoginAttempt");
	AddEvent("OnPlayerUpdate");
	AddEvent("OnPlayerStreamIn");
	AddEvent("OnPlayerStreamOut");
	AddEvent("OnVehicleStreamIn");
	AddEvent("OnVehicleStreamOut");
	AddEvent("OnDialogResponse");
	AddEvent("OnPlayerClickPlayer");
	AddEvent("OnPlayerExitMenu");
	AddEvent("OnPlayerGiveDamage");
	AddEvent("OnPlayerTakeDamage");
	AddEvent("OnPlayerClickMap");
	AddEvent("OnVehicleDamageStatusUpdate");
	AddEvent("OnUnoccupiedVehicleUpdate");
	AddEvent("OnEnterExitModShop");
	AddEvent("OnPlayerEditObject");
	AddEvent("OnPlayerEditAttachedObject");
	AddEvent("OnPlayerSelectObject");
	AddEvent("OnPlayerClickTextDraw");
	AddEvent("OnPlayerClickPlayerTextDraw");
	AddEvent("OnIncomingConnection");
	AddEvent("OnPlayerWeaponShot");
	AddEvent("OnTrailerUpdate");
	AddEvent("OnActorStreamIn");
	AddEvent("OnActorStreamOut");
	AddEvent("OnPlayerGiveDamageActor");
	AddEvent("OnVehicleSirenStateChange");
	AddEvent("OnPlayerCommandTextFail");

	ShowQModuleInitMessage();

	if(type == 0) AddEventHandler(D_FilterScriptInit, "__InitMain");
	else AddEventHandler(D_GameModeInit, "__InitMain");
}

stock IsValidEvent(eventid)
{
	if(eventid < 0) printf("[QModule] Invalid event ID: %d", eventid);
	else if(eventid >= eventIDX) printf("[QModule] Event ID(id: %d) out of range. Current range is: %d", eventid, eventIDX);
	else return 1;

	return 0;
}

static stock ShowQModuleInitMessage()
{
	print("============================================");
	print("                  QModule                   ");
	print("             version: "QMODULE_ENGINE_VERSION"");
	print("                author: Qoo                 ");
	print("Copyright (c) 2018-2019 Qoo. All rights reserved.");
	print("=============================================");
}

/*stock strfix(const source[])
{
	new chString[1024];
	if(IsNull(source) == false) strmid(chString, source, 0, strlen(source), 1024);
	else chString = "NULL";
	return chString;
}*/
